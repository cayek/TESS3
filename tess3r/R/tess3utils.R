#' Create grid on which coefficients will be displayed
#'
#' \code{createGridFromAsciiRaster} returns a grid to use to project clusters on a map. The grid is computed from an ascii raster file.
#'
#' @param file A character string containing a the path to the ascii raster file.
#'
#' @return \code{createGridFromAsciiRaster} returns a matrix which represent the grid extract from the raster file.
#'
#' @seealso This function was made to be used with \code{\link{getConstraintsFromAsciiRaster}} and \code{\link{maps}}.
#'
#' @export
createGridFromAsciiRaster = function(file)

  # return a grid to use to project clusters on a map
  # the grid is computed from an ascii raster file

{
  info=read.table(file,nrows=6)
  grid.info=info[,2]
  names(grid.info)=info[,1]
  lat.pix=seq(from=grid.info["YLLCENTER"],by=grid.info["CELLSIZE"],length=grid.info["NROWS"])
  long.pix=seq(from=grid.info["XLLCENTER"],by=grid.info["CELLSIZE"],length=grid.info["NCOLS"])
  grid=fields::make.surface.grid( list( long.pix,lat.pix))

  return(grid)
}


#' Create grid on which coefficients will be displayed
#'
#' \code{getConstraintsFromAsciiRaster} compute a constraint matrix acording to the \code{cell_value_min} and \code{cell_value_max} values.
#'
#' @param file A character string containing a the path to the ascii raster file.
#' @param cell_value_min All case values inferior to this numeric value will be set to FALSE on the grid.
#' @param cell_value_max All case values superior to this numeric value will be set to FALSE on the grid.
#'
#' @return \code{getConstraintsFromAsciiRaster} returns a matrix with boolean cells.
#' Cells is set to TRUE if user wants to project on this map's cell
#'
#' @seealso This function was made to be used with \code{\link{createGridFromAsciiRaster}} and \code{\link{maps}}.
#'
#' @export
getConstraintsFromAsciiRaster = function(file,cell_value_min=NULL,cell_value_max=NULL)
{
  map=read.table(file,skip=6)
  map=t(map)[,nrow(map):1]

  # 3 suggested constraints that you can remove if needed:

  map_constraints=!is.na(map)

  if (!is.null(cell_value_min)) {
    map_constraints[map<cell_value_min]=FALSE
  }

  if (!is.null(cell_value_max)) {
    map_constraints[map>cell_value_max]=FALSE
  }

  # you can add constraints here, example:
  # map_constraints["condition where you do not want to project clusters"]=FALSE

  return(map_constraints)
}

lColorGradients = list(
  c("gray95",RColorBrewer::brewer.pal(9,"Reds")),
  c("gray95",RColorBrewer::brewer.pal(9,"Greens")),
  c("gray95",RColorBrewer::brewer.pal(9,"Blues")),
  c("gray95",RColorBrewer::brewer.pal(9,"YlOrBr")),
  c("gray95",RColorBrewer::brewer.pal(9,"RdPu")),
  c("gray95",RColorBrewer::brewer.pal(9,"Greys"))
)


#' Display maps of membership/admixture coefficients.
#'
#' \code{\link{maps}} projects membership/admixture coefficients on a grid using \code{\link[fields]{Krig}}.
#' Gradients in coefficients are represented by gradients in colors.
#' if \code{onemap == T & method == "treshold"} only \code{coefficients > 0.5} are plotted.
#' if \code{onemap == T & method == "max"} at each point the cluster for which the coefficient
#' is maximal is plotted (even if the value is less than 0.5).
#' if \code{onemap == F} all values are plotted (since there is one cluster represented on each map, there is no overlap problem).
#'
#' @param matrix Matrix of values to interpolate.
#' @param coord Matrix of corrdinate values.
#' @param grid Matrix with grid values. Can be generated by \code{\link{createGridFromAsciiRaster}}.
#' @param constraints Matrix with constraints values. Can be generated by \code{\link{createGridFromAsciiRaster}}.
#' @param method A character string which can be "treshold" or "max".
#' @param colorGradientsList A list of string which defines what color are used to plot the interpolation result.
#' @param onemap A boolean value.
#' @param onepage A boolean value.
#'
#' @examples
#' ## How maps can be used to plot TESS3 function output ##
#'
#' #################
#' # runs of TESS3 #
#' #################
#' # Retrieve data file name
#' genotype.file <- system.file("extdata/Athaliana","Athaliana.geno",package = "tess3r")
#' coord.file <- system.file("extdata/Athaliana","Athaliana.coord",package = "tess3r")
#' # Read coordinate file
#' coord <- read.coord(coord.file)
#' n <- nrow(coord)
#'
#' project <- TESS3(input.file = genotype.file,
#'                  input.coord = coord.file,
#'                  K = 1:5,
#'                  ploidy = 1,
#'                  repetitions = 1,
#'                  entropy = TRUE,
#'                  percentage = 0.2,
#'                  project = "new")
#'
#' #####################
#' # Plot result on map#
#' #####################
#'
#' asciiFile=system.file("extdata/","lowResEurope.asc",package = "tess3r")
#' grid=createGridFromAsciiRaster(asciiFile)
#' # To display only altitudes above 0:
#' constraints=getConstraintsFromAsciiRaster(asciiFile,cell_value_min=0)
#'
#' maps(matrix = Q( project, K = 3, run = 1 ),
#'      coord = coord,
#'      grid=grid,constraints=constraints,method="max",main="ancestry coefficient with K = 3")
#'
#' @seealso This function was made to used with \code{\link{createGridFromAsciiRaster}}, \code{\link{maps}} and \code{\link{TESS3}}
#'
#' @export
maps = function(matrix,coord,grid,constraints=NULL,method="treshold",colorGradientsList=lColorGradients,onemap=T,onepage=T,...)
{

  if ( (method != "treshold") & (method != "max")) {stop(paste("Unknown method",method))}
  if (class(constraints)!= "NULL") {
    if ( nrow(grid) != nrow(constraints)*ncol(constraints) ) {
      stop(paste("Argument grid assumes", nrow(grid), "pixels, but argument constaints assumes", nrow(constraints)*ncol(constraints),"pixels"))
    }
  }

  if (onemap & method=="max") {
    mapsMethodMax(matrix=matrix,coord=coord,grid=grid,constraints=constraints,colorGradientsList=colorGradientsList,...)

  } else {
    K=ncol(matrix)
    if (length(colorGradientsList)<K)
    {
      stop(paste(K,"clusters detected but only",length(colorGradientsList),"color gradient(s) defined.",
                 "You should complete colorGradientsList to have as many gradients as clusters."))
    }

    if (!onemap & onepage) {KK = as.integer(K/2); par(mfrow = c(2,KK+1)) }

    for (k in 1:K)
    {
      clust=NULL
      clust= fields::Krig(coord, matrix[,k], theta = 10)
      look<- predict(clust,grid) # evaluate on a grid of points
      out<- fields::as.surface( grid, look)

      if (class(constraints)!= "NULL") { out[[8]][ !constraints ] = NA }

      ncolors=length(colorGradientsList[[k]])
      if (onemap)
      {
        out[[8]][ out[[8]] < .5 ] = NA
        graphics::image(out,add=(k>1),col=colorGradientsList[[k]][(ncolors-4):ncolors],breaks=c(seq(.5,.9,.1),+200),...)
      } else {
        graphics::image(out,col=colorGradientsList[[k]][(ncolors-9):ncolors],breaks=c(-200,.1,seq(.2,.9,.1),+200),...)
        graphics::points(coord,pch=19)
      }
    }

    if (onemap) { graphics::points(coord,pch=19) }
  }

}

mapsMethodMax = function(matrix,coord,grid,constraints,colorGradientsList,...)

{
  K=ncol(matrix)
  if (length(colorGradientsList)<K)
  {
    stop(paste(K,"clusters detected but only",length(colorGradientsList),"color gradient(s) defined.",
               "You should complete colorGradientsList to have as many gradients as clusters."))
  }

  listOutClusters=NULL
  matrixOfVectors =NULL
  for (k in 1:K)
  {
    clust=NULL
    clust= fields::Krig(coord, matrix[,k], theta = 10)
    look<- predict(clust,grid) # evaluate on a grid of points
    out<- fields::as.surface( grid, look)
    listOutClusters[[k]] = out[[8]]
    matrixOfVectors = cbind(matrixOfVectors,c(out[[8]]))
  }
  long = out[[1]]
  lat = out[[2]]

  whichmax = matrix(apply(matrixOfVectors ,MARGIN=1,FUN=which.max),nrow=length(long))

  for (k in 1:K)
  {
    ncolors=length(colorGradientsList[[k]])
    if (class(constraints)!= "NULL") { listOutClusters[[k]][ !constraints ] = NA }
    listOutClusters[[k]][ whichmax != k ] = NA
    image(long,lat,listOutClusters[[k]],add=(k>1),col=colorGradientsList[[k]][(ncolors-9):ncolors],breaks=c(-200,.1,seq(.2,.9,.1),+200),...)
  }
  points(coord,pch=19)
}


#' @useDynLib tess3r wrapper_createdataset
create.dataset <- function(input.file, output.file, seed = -1,
                           percentage = 0.05)
{
  # test arguments and init
  # input file
  input.file = test_character("input.file", input.file, NULL)
  # check extension and convert if necessary
  input.file = test_input_file(input.file, "geno")
  # output file
  tmp = sub("([^.]+)\\.[[:alnum:]]+$", "\\1_I.geno",input.file)
  output.file = test_character("output.file", output.file, tmp)
  # seed
  seed = test_integer("seed", seed,
                      as.integer(runif(1)*.Machine$integer.max))
  if (seed == -1)
    seed = as.integer(runif(1)*.Machine$integer.max)
  set.seed(seed) # init seed
  print(seed)
  # percentage
  percentage = test_double("percentage", percentage, 0.05)
  if (percentage <= 0 || percentage >= 1)
    stop(paste("'percentage' argument has to be of type double and ",
               "between 0 and 1.", sep=""))

  print("*************************************");
  print("*          create.dataset            *");
  print("*************************************");

  # run method
  .C("wrapper_createdataset",
     as.character(input.file),
     as.integer(seed),
     as.double(percentage),
     as.character(output.file)
  );

  # create output
  return(output.file);
}

#' @useDynLib tess3r wrapper_crossEntropy
cross.entropy.estimation <- function(input.file, K, masked.file, Q.file,
                                     G.file, ploidy = 2) {

  # test arguments and init
  # input file
  input.file = test_character("input.file", input.file, NULL)
  # check extension and convert if necessary
  input.file = test_input_file(input.file, "geno")
  # K
  K = test_integer("K", K, NULL)
  if (K <= 0)
    stop("'K' argument has to be positive.")
  # masked data file
  tmp = setExtension(input.file, "_I.geno");
  masked.file = test_character("masked.file", masked.file, tmp)
  # check extension
  test_extension(masked.file, "geno")
  # Q file
  tmp = paste(setExtension(input.file, ""), "_I.", K, ".Q", sep="")
  Q.file = test_character("Q.file", Q.file, tmp)
  # check extension
  test_extension(Q.file, "Q")
  # G file
  tmp = paste(setExtension(input.file, ""), "_I.", K, ".G", sep="")
  G.file = test_character("G.file", G.file, tmp)
  # check extension
  test_extension(G.file, "G")
  # ploidy
  ploidy = test_integer("ploidy", ploidy, 2)
  if (ploidy <= 0)
    stop("'ploidy' argument has to be positive.")

  print("*************************************");
  print("*    cross-entropy estimation       *");
  print("*************************************");

  # run method
  all.ce = 0;
  masked.ce = 0;
  res = .C("wrapper_crossEntropy",
           as.character(input.file),
           as.character(masked.file),
           as.character(Q.file),
           as.character(G.file),
           as.integer(K),
           as.integer(ploidy),
           all.ce = as.double(all.ce),
           masked.ce = as.double(masked.ce)
  )

  return(list(masked.ce=res$masked.ce, all.ce=res$all.ce))
}

#' @export
read.coord <- function( file ) {

  if (file.exists( file = file )) {

    return(as.matrix(read.table( file = file )))

  } else {

    stop(paste("Can not find the file:", file))
  }

}

